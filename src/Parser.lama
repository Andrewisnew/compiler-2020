-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  s(l) |> lift (p |> bypass (s(r)))
}

fun binop (o) {
  [s(o), fun(l, r) { Binop (o, l, r) }]
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", exp, ")"));

local stElif = memo $ eta (kElif |> lift (exp |> fun (e) {
                            kThen |> lift (stmt |> fun (s1) {
                                kElse |> lift (stmt |> fun (s2) {
                                        kFi @ lift (If (e, s1, s2))
                                    }) | 
                                kFi @ lift (If (e, s1, Skip)) | 
                                stElif @ fun (s2) {If (e, s1, s2)}
                                })
                            })
                        );  

local exp = memo $ eta (expr(
{ 
  [Left, singleton(binop("!!"))],
  [Left, singleton(binop("&&"))],
  [Nona, {binop("<"), binop(">"), binop("<="), binop(">="), binop("=="), binop("!=")}],
  [Left, {binop("+"), binop("-")}],
  [Left, {binop("*"), binop("/"), binop("%")}]
}, primary)(id));

local st = memo $ eta (kSkip @ lift(Skip) |
                       kRead  |> lift(primary @ fun (Var(x)) {Read(x)}) |
                       kWrite |> lift(exp @ fun (x) {Write(x)}) |
                       lident |> fun(x) {s(":=") |> lift(exp @ fun (e) {Assn(x, e)})} |
                       kIf    |> lift(exp |> fun (e) {
                         kThen |> lift(stmt |> fun (s1) {
                           kElse |> lift(stmt |> fun (s2) {kFi @ lift(If (e, s1, s2))}) | 
                           kFi @ lift(If(e, s1, Skip)) | 
                           stElif @ fun (s2) {If(e, s1, s2)}
                         })}) |
                       kWhile |> lift (exp |> fun (e) {
                         kDo |> lift (stmt |> fun (s) {
                           kOd @ lift (While(e, s))})}) |
                       kRepeat |> lift (stmt |> fun (s) {
                         kUntil |> lift (exp @ fun (e) {Repeat(s, e)})}) |
                       kFor |> lift (stmt |> fun (s1) {
                         s(",") |> lift (exp |> fun (e) {
                           s(",") |> lift (stmt |> fun (s2) {
                             kDo |> lift (stmt |> fun (s3) {
                               kOd @ lift (Seq (s1, While(e, Seq(s3, s2))))})})})}));

local stmt = memo $ eta (st |
                         st |> fun (s1) {s(";") |> lift(stmt @ fun (s2) {Seq(s1, s2)})});
   

-- Public top-level parser
public parse = stmt;
